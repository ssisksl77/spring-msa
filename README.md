# spring-msa
스프링 MSA 공부 시작!

# Config 관리
Spring Cloud Config를 이용한 컨피그 관리
## 필요성
일반적으로 이런 프로퍼티들은 어플리케이션이 설치되는 곳에 환경변수로 저장하거나 특정 패스에 파일을 저장해서 가져오는 방식을 사용한다.
이는 어렵지 않으나 여러 개의 마이크로서비스와 마이크로 인스턴스를 사용하게 되면 문제가 된다고 한다.
환경변수, 설정파일이 어디에 저장되고 어떤 형식으로 저장할지 결정해야 하기 때문
구축 순서  
1. 깃허브에 프로퍼티 생성
2. Config Server 생성
3. Config Client 생성
4. Actuator로 자동 리프레쉬 테스트  
- [스프링 클라우드 서버](https://github.com/ssisksl77/spring-msa/tree/master/spring-config-server)  
- [스프링 클라우드 클라이언트](https://github.com/ssisksl77/spring-msa/tree/master/spring-config-client-1)

# 서비스 디스커버리
스프링 유레카를 이용한 서비스 구축
## 필요성
분산 아키텍처에서는 시스템의 물리적 위치를 찾아야 한다. 마이크로 서비스에서 서비스 디스커버리가 중요한 이유는 다음과 같다.
1. 애플리케애션 팀은 서비스 디스커버리를 이용하여 해당 환경에서 서비스 인스턴스 개수를 수평 확장/축소 할 수 있다. 서비스 디스커버리를 통해 서비스의 물리적 위치는 서비스 소비자에게 드러나지 않는다. 이렇게 물리적 위치를 모르기 때문에 인스턴스의 추가/제거가 자유롭다
2. 애플리케이션 회복성이 증가한다. 특정 서비스가 비정상이거나 가용하지 않으면 가용 서비스 목록에서 제거한다. 다운된 서비스로 야기되는 피해를 최소화한다.
그런데 DNS나 로드 밸런서로는 안되는 걸까?  이런 패턴은 회사 내 데이터센터 안에서 실행되는 애플리케이션과 정적 서버 그룹에서 실행되는 소수 서비스에서는 잘 동작한다. 하지만 클라우드 기반의 마이크로서비스 애플리케이션에서는 그렇지 못하다.
1. 단일 장애 지점 : 로드밸런서가 고가용성을 지원한다해도 여전히 전체 인프라스트럭처의 단일 장애 지점이다. 병목지점이 될 수도 있고, 로드밸런서가 죽으면 다 죽은 것
2. 수평 확장의 제약 : 여러 서버를 수평적으로 증가하는 능력이 제한된다. 일단 서비스를 모두 클러스터에 모아 연결하기 때문이다. 
3. 정적 관리 : 전통적 로드 밸런서는 신속히 등록하고 취소하도록 설계되어 있지 않다. 
4. 복잡성 : 로드 밸런서가 서비스에 대한 프록시 역할을 하므로 서비스 소비자에게 요청할 때 물리적인 서비스에 매핑된 요청 정보가 있어야 한다.
구축 순서
